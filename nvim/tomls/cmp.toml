[[plugins]]
repo = 'hrsh7th/nvim-cmp'
on_event = 'VimEnter'
lua_source = '''
  local has_words_before = function()
    unpack = unpack or table.unpack
    local line, col = unpack(vim.api.nvim_win_get_cursor(0))
    return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match("%s") == nil
  end

  local feedkey = function(key, mode)
    vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(key, true, true, true), mode, true)
  end

  vim.g.use_nerd_icons = false
  function icons()
    if vim.fn.has "mac" == 1 or vim.g.use_nerd_icons then
      return {
        kind = {
          -- Text = "",
          Text = "✏︎",
          Method = "m",
          Function = "λ",
          Constructor = "",
          -- Method = "",
          -- Function = "",
          -- Constructor = "",
          Field = "",
          -- Variable = "",
          Variable = "",
          -- Class = "",
          Class = "c",
          Interface = "",
          Module = "",
          -- Module = "",
          Property = "",
          Unit = "",
          -- Value = "",
          Value = "v",
          Enum = "",
          -- Keyword = "",
          Keyword = "",
          Snippet = "",
          -- Snippet = "",
          Color = "",
          File = "",
          Reference = "",
          Folder = "",
          EnumMember = "",
          Constant = "",
          Struct = "",
          Event = "",
          Operator = "",
          TypeParameter = "",
        },
        type = {
          -- Array = "",
          Array = "🗃",
          Number = "",
          -- String = "",
          String = "📖",
          Boolean = "蘒",
          -- Object = "",
          Object = "🗂",
        },
        documents = {
          File = "",
          Files = "",
          Folder = "",
          OpenFolder = "",
        },
        git = {
          Add = "",
          Mod = "",
          Remove = "",
          Ignore = "",
          Rename = "",
          Diff = "",
          Repo = "",
          Octoface = "",
        },
        ui = {
          ArrowClosed = "",
          ArrowOpen = "",
          Lock = "",
          Circle = "",
          BigCircle = "",
          BigUnfilledCircle = "",
          Close = "",
          NewFile = "",
          Search = "",
          Lightbulb = "",
          Project = "",
          Dashboard = "",
          History = "",
          Comment = "",
          Bug = "",
          Code = "",
          Telescope = "",
          Gear = "",
          Package = "",
          List = "",
          SignIn = "",
          SignOut = "",
          Check = "",
          Fire = "",
          Note = "",
          BookMark = "",
          Pencil = "",
          -- ChevronRight = "",
          ChevronRight = ">",
          Table = "",
          Calendar = "",
          CloudDownload = "",
        },
        diagnostics = {
          Error = "",
          Warning = "",
          Information = "",
          Question = "",
          Hint = "",
        },
        misc = {
          Robot = "ﮧ",
          Squirrel = "",
          Tag = "",
          Watch = "",
          Smiley = "ﲃ",
          Package = "",
          CircuitBoard = "",
        },
      }
    else
      return {
        kind = {
          Text = " ",
          Method = " ",
          Function = " ",
          Constructor = " ",
          Field = " ",
          Variable = " ",
          Class = " ",
          Interface = " ",
          Module = " ",
          Property = " ",
          Unit = " ",
          Value = " ",
          Enum = " ",
          Keyword = " ",
          Snippet = " ",
          Color = " ",
          File = " ",
          Reference = " ",
          Folder = " ",
          EnumMember = " ",
          Constant = " ",
          Struct = " ",
          Event = " ",
          Operator = " ",
          TypeParameter = " ",
          Misc = " ",
        },
        type = {
          Array = " ",
          Number = " ",
          String = " ",
          Boolean = " ",
          Object = " ",
        },
        documents = {
          File = " ",
          Files = " ",
          Folder = " ",
          OpenFolder = " ",
        },
        git = {
          Add = " ",
          Mod = " ",
          Remove = " ",
          Ignore = " ",
          Rename = " ",
          Diff = " ",
          Repo = " ",
          Octoface = " ",
        },
        ui = {
          ArrowClosed = "",
          ArrowOpen = "",
          Lock = " ",
          Circle = " ",
          BigCircle = " ",
          BigUnfilledCircle = " ",
          Close = " ",
          NewFile = " ",
          Search = " ",
          Lightbulb = " ",
          Project = " ",
          Dashboard = " ",
          History = " ",
          Comment = " ",
          Bug = " ",
          Code = " ",
          Telescope = " ",
          Gear = " ",
          Package = " ",
          List = " ",
          SignIn = " ",
          SignOut = " ",
          NoteBook = " ",
          Check = " ",
          Fire = " ",
          Note = " ",
          BookMark = " ",
          Pencil = " ",
          ChevronRight = "",
          Table = " ",
          Calendar = " ",
          CloudDownload = " ",
        },
        diagnostics = {
          Error = " ",
          Warning = " ",
          Information = " ",
          Question = " ",
          Hint = " ",
        },
        misc = {
          Robot = " ",
          Squirrel = " ",
          Tag = " ",
          Watch = " ",
          Smiley = " ",
          Package = " ",
          CircuitBoard = " ",
        },
      }
    end
  end

  local icn = icons()
  local kind_icons = icn.kind

  local cmp = require("cmp")
  cmp.setup({
    snippet = {
      expand = function(args)
        vim.fn["vsnip#anonymous"](args.body)
      end,
    },
    formatting = {
      fields = { "kind", "abbr", "menu" },
      format = function(entry, vim_item)
        -- Kind icons
        vim_item.kind = kind_icons[vim_item.kind]

        if entry.source.name == "copilot" then
          vim_item.kind = icn.git.Octoface
          vim_item.kind_hl_group = "CmpItemKindCopilot"
        end

        if entry.source.name == "emoji" then
          vim_item.kind = icn.misc.Smiley
          vim_item.kind_hl_group = "CmpItemKindEmoji"
        end

        if entry.source.name == "crates" then
          vim_item.kind = icn.misc.Package
          vim_item.kind_hl_group = "CmpItemKindCrate"
        end

        if entry.source.name == "lab.quick_data" then
          vim_item.kind = icn.misc.CircuitBoard
          vim_item.kind_hl_group = "CmpItemKindConstant"
        end

        -- NOTE: order matters
        vim_item.menu = ({
          nvim_lsp = "",
          nvim_lua = "",
          luasnip = "",
          buffer = "",
          path = "",
          emoji = "",
        })[entry.source.name]
        return vim_item
      end,
    },
    window = {
      completion = cmp.config.window.bordered({
        border = 'double'
      }),
      documentation = cmp.config.window.bordered({
        border = 'double'
      }),
    },
    sources = {
      { name = "nvim_lsp",                priority = 10 },
      { name = 'vsnip',                   priority = 9 },
      { name = "path",                    priority = 8 },
      { name = "buffer",                  priority = 7 },
      { name = "nvim_lsp_signature_help", priority = 6 },
      { name = "emoji",                   priority = 1 },
    },
    mapping = cmp.mapping.preset.insert({
      ["<C-p>"] = cmp.mapping.select_prev_item(),
      ["<C-n>"] = cmp.mapping.select_next_item(),
      ['<C-l>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.abort(),
      ['<C-f>'] = cmp.mapping.scroll_docs(4),
      ['<C-b>'] = cmp.mapping.scroll_docs(-4),
      ["<CR>"] = cmp.mapping.confirm { select = true },
      ["<Tab>"] = cmp.mapping(function(fallback)
        if cmp.visible() then
          cmp.select_next_item()
        elseif vim.fn["vsnip#available"](1) == 1 then
          feedkey("<Plug>(vsnip-expand-or-jump)", "")
        elseif has_words_before() then
          cmp.complete()
        else
          fallback() -- The fallback function sends a already mapped key. In this case, it's probably `<Tab>`.
        end
      end, { "i", "s" }),
      ["<S-Tab>"] = cmp.mapping(function()
        if cmp.visible() then
          cmp.select_prev_item()
        elseif vim.fn["vsnip#jumpable"](-1) == 1 then
          feedkey("<Plug>(vsnip-jump-prev)", "")
        end
      end, { "i", "s" }),
    }),
    experimental = {
      ghost_text = true,
    },
  })

  -- Set configuration for specific filetype.
  cmp.setup.filetype('gitcommit', {
    sources = cmp.config.sources({
      { name = 'cmp_git' }, -- You can specify the `cmp_git` source if you were installed it.
    }, {
      { name = 'buffer' },
    })
  })

  -- Use buffer source for `/` and `?` (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline({ '/', '?' }, {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
      { name = 'buffer' }
    }
  })

  -- Use cmdline & path source for ':' (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline(':', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      { name = 'cmdline' }
    })
  })
'''

[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-buffer'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-path'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-cmdline'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp-signature-help'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp-document-symbol'
on_event = 'VimEnter'

[[plugins]]
repo = 'onsails/lspkind.nvim'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_event = 'VimEnter'
lua_source = '''
  vim.g.vsnip_snippet_dir = "$HOME/.config/nvim/snippets"
'''
lua_post_source = '''
  vim.cmd [[
    autocmd User PumCompleteDone call vsnip_integ#on_complete_done(g:pum#completed_item)
    autocmd BufWritePre <buffer> lua vim.lsp.buf.format({}, 10000)
  ]]
'''

[[plugins]]
repo = 'hrsh7th/cmp-vsnip'
on_event = 'VimEnter'

[[plugins]]
repo = 'github/copilot.vim'
on_event = 'VimEnter'
lua_source = '''
  vim.g.copilot_filetypes = {
    gitcommit = true,
    markdown = true,
    yaml = true,
    text = true,
  }
  vim.g.copilot_no_tab_map = true

  vim.keymap.set(
    "i",
    "<C-c>",
    'copilot#Accept()',
    { silent = true, expr = true, script = true, replace_keycodes = false }
  )
  vim.keymap.set(
    "i",
    "<C-x>",
    '<Plug>(copilot-dismiss)'
  )
'''
lua_post_source = '''
  local function append_diff()
    -- Get the Git repository root directory
    local git_dir = vim.fn.FugitiveGitDir()
    local git_root = vim.fn.fnamemodify(git_dir, ':h')
    -- Get the diff of the staged changes relative to the Git repository root
    local diff = vim.fn.system('git -C ' .. git_root .. ' diff --cached')
    -- Add a comment character to each line of the diff
    local comment_diff = table.concat(vim.tbl_map(function(line)
      return '# ' .. line
    end, vim.split(diff, '\n')), "\n")
    -- Append the diff to the commit message
    vim.api.nvim_buf_set_lines(0, -1, -1, false, vim.split(comment_diff, '\n'))
  end
  vim.cmd [[
    autocmd BufReadPost COMMIT_EDITMSG call lua append_diff()
  ]]
'''

[[plugins]]
repo = 'williamboman/mason-lspconfig.nvim'
on_event = 'VimEnter'

[[plugins]]
repo = 'williamboman/mason.nvim'
on_event = 'VimEnter'
lua_post_source = '''
  require("mason").setup({
    ui = {
      icons = {
        package_installed = "✓",
        package_pending = "➜",
        package_uninstalled = "✗"
      }
    }
  })
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_event = 'VimEnter'
depends = ['mason-lspconfig.nvim', 'cmp-nvim-lsp']
lua_post_source = '''
  local on_attach = function(client, bufnr)
    local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end

    local opts = { noremap = true, silent = true }
    buf_set_keymap("n", "K", "<cmd>lua vim.lsp.buf.hover()<CR>", opts)
    buf_set_keymap("n", "gD", "<cmd>lua vim.lsp.buf.declaration()<CR>", opts)
    buf_set_keymap("n", "gd", "<cmd>lua vim.lsp.buf.definition()<CR>", opts)
    buf_set_keymap("n", "gvd", "<cmd>:vsp<CR><cmd>lua vim.lsp.buf.definition()<CR>", opts)
    buf_set_keymap("n", "gsd", "<cmd>:sp<CR><cmd>lua vim.lsp.buf.definition()<CR>", opts)
    buf_set_keymap("n", "gi", "<cmd>lua vim.lsp.buf.implementation()<CR>", opts)
    buf_set_keymap("n", "gr", "<cmd>lua vim.lsp.buf.references()<CR>", opts)
    buf_set_keymap('n', 'gt', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
    buf_set_keymap("n", "gn", "<cmd>lua vim.lsp.buf.rename()<CR>", opts)
    buf_set_keymap("n", "gf", "<cmd>lua vim.lsp.buf.format { async = true }<CR>", opts)
    buf_set_keymap('n', 'ge', '<cmd>lua vim.diagnostic.open_float()<CR>', opts)
    buf_set_keymap("n", "<C-k>", "<cmd>lua vim.lsp.buf.signature_help()<CR>", opts)
    buf_set_keymap("n", "<space>wa", "<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>", opts)
    buf_set_keymap("n", "<space>wr", "<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>", opts)
    buf_set_keymap("n", "<space>wl", "<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>", opts)
    buf_set_keymap("n", "<space>D", "<cmd>lua vim.lsp.buf.type_definition()<CR>", opts)
    buf_set_keymap("n", "<space>ca", "<cmd>lua vim.lsp.buf.code_action()<CR>", opts)
    buf_set_keymap("n", "<space>e", "<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>", opts)
    buf_set_keymap("n", "[d", "<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>", opts)
    buf_set_keymap("n", "]d", "<cmd>lua vim.lsp.diagnostic.goto_next()<CR>", opts)
    buf_set_keymap("n", "<space>q", "<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>", opts)
  end

  local capabilities = require('cmp_nvim_lsp').default_capabilities()
  capabilities.textDocument.completion.completionItem.snippetSupport = true

  vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
    vim.lsp.diagnostic.on_publish_diagnostics, {
      underline = true,
      virtual_text = true,
      signs = true,
      update_in_insert = false,
    }
  )
  -- diagnostic sign setting
  local signs = { Error = "🙅", Warn = "⚠️", Hint = "💡", Info = "🙋" }
  for type, icon in pairs(signs) do
    local hl = "DiagnosticSign" .. type
    vim.fn.sign_define(hl, { text = icon, texthl = hl, numhl = hl })
  end

  local nvim_lsp = require("lspconfig")
  -- require("mason-lspconfig").setup()
  require("mason-lspconfig").setup_handlers {
    function(server_name)
      local opt = {
        on_attach = on_attach,
        capabilities = capabilities,
      }
      if server_name == "gopls" then
        opt.settings = {
          gopls = {
            env = { GOFLAGS = "-tags=integration,!integration,wireinject" },
            gofumpt = true,
          },
        }
      elseif server_name == "tsserver" then
        -- package.json と deno.json があるディレクトリ場合は tsserver を使う
        opt.root_dir = nvim_lsp.util.root_pattern("package.json")
      elseif server_name == "denols" then
        opt.root_dir = nvim_lsp.util.root_pattern("deno.json")
      end
      nvim_lsp[server_name].setup(opt)
    end
  }
'''

[[plugins]]
repo = 'stevearc/aerial.nvim'
on_event = 'VimEnter'
lua_post_source = '''
  require("aerial").setup({
    layout = {
      -- These control the width of the aerial window.
      -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
      -- min_width and max_width can be a list of mixed types.
      -- max_width = {40, 0.2} means "the lesser of 40 columns or 20% of total"
      max_width = { 50, 0.2 },
      width = nil,
      min_width = 30,

      -- key-value pairs of window-local options for aerial window (e.g. winhl)
      win_opts = {},

      -- Determines the default direction to open the aerial window. The 'prefer'
      -- options will open the window in the other direction *if* there is a
      -- different buffer in the way of the preferred direction
      -- Enum: prefer_right, prefer_left, right, left, float
      default_direction = "prefer_right",

      -- Determines where the aerial window will be opened
      --   edge   - open aerial at the far right/left of the editor
      --   window - open aerial to the right/left of the current window
      placement = "window",

      -- When the symbols change, resize the aerial window (within min/max constraints) to fit
      resize_to_content = true,

      -- Preserve window size equality with (:help CTRL-W_=)
      preserve_equality = false,
    }
  })
'''
