[[plugins]]
repo = 'hrsh7th/nvim-cmp'
on_event = 'VimEnter'
lua_source = '''
  local has_words_before = function()
    unpack = unpack or table.unpack
    local line, col = unpack(vim.api.nvim_win_get_cursor(0))
    return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match("%s") == nil
  end

  local feedkey = function(key, mode)
    vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(key, true, true, true), mode, true)
  end

  vim.g.use_nerd_icons = false
  function icons()
    if vim.fn.has "mac" == 1 or vim.g.use_nerd_icons then
      return {
        kind = {
          -- Text = "Ôùæ",
          Text = "‚úèÔ∏é",
          Method = "m",
          Function = "Œª",
          Constructor = "Ôê•",
          -- Method = "Ôö¶",
          -- Function = "Ôö¶",
          -- Constructor = "Ôö¶",
          Field = "Óúñ",
          -- Variable = "Ôö¶",
          Variable = "Óúñ",
          -- Class = "Ô†ñ",
          Class = "c",
          Interface = "ÔÉ®",
          Module = "Ôíá",
          -- Module = "Ôô®",
          Property = "ÔÇ≠",
          Unit = "Óàü",
          -- Value = "Ô¢ü",
          Value = "v",
          Enum = "ÔÖù",
          -- Keyword = "Ô†ä",
          Keyword = "Ôùß",
          Snippet = "ÔÉÑ",
          -- Snippet = "Ôóè",
          Color = "Ô£ó",
          File = "ÔÄñ",
          Reference = "ÔíÅ",
          Folder = "ÔÑî",
          EnumMember = "ÔÖù",
          Constant = "Ôõº",
          Struct = "ÔÜ≥",
          Event = "ÔÉß",
          Operator = "Ôöî",
          TypeParameter = "ÔûÉ",
        },
        type = {
          -- Array = "Ôôß",
          Array = "üóÉ",
          Number = "Ôäí",
          -- String = "Ôùæ",
          String = "üìñ",
          Boolean = "Ô®†",
          -- Object = "Ôô®",
          Object = "üóÇ",
        },
        documents = {
          File = "ÔÄñ",
          Files = "ÔÉÖ",
          Folder = "ÔÑî",
          OpenFolder = "ÔÑï",
        },
        git = {
          Add = "Ôëó",
          Mod = "Ôëô",
          Remove = "Ôëò",
          Ignore = "Ôë¥",
          Rename = "Ôëö",
          Diff = "ÔëÄ",
          Repo = "ÔêÅ",
          Octoface = "ÔêÜ",
        },
        ui = {
          ArrowClosed = "Ôë†",
          ArrowOpen = "Ôëº",
          Lock = "Ô°Ä",
          Circle = "ÔÑë",
          BigCircle = "ÔÑë",
          BigUnfilledCircle = "ÔÑë",
          Close = "Ôôï",
          NewFile = "ÔÖõ",
          Search = "Ô°à",
          Lightbulb = "Ô†¥",
          Project = "ÔÅª",
          Dashboard = "Ôë£",
          History = "Ôòà",
          Comment = "Ôôπ",
          Bug = "ÔÜà",
          Code = "Óûñ",
          Telescope = "Ôë´",
          Gear = "Ôê£",
          Package = "Ôíá",
          List = "ÔÄ¢",
          SignIn = "Ôê™",
          SignOut = "Ôê¶",
          Check = "Ôò´",
          Fire = "Ôíê",
          Note = "Ô¢ù",
          BookMark = "ÔÇó",
          Pencil = "Ô£™",
          -- ChevronRight = "ÔÅî",
          ChevronRight = ">",
          Table = "ÔÉé",
          Calendar = "ÔÅ≥",
          CloudDownload = "Ôêâ",
        },
        diagnostics = {
          Error = "ÔÅó",
          Warning = "ÔÅ±",
          Information = "ÔÅö",
          Question = "ÔÅô",
          Hint = "Ô†¥",
        },
        misc = {
          Robot = "ÔÆß",
          Squirrel = "ÔíÉ",
          Tag = "ÔÄ´",
          Watch = "ÓéÖ",
          Smiley = "Ô≤É",
          Package = "ÔÜ≤",
          CircuitBoard = "Ôíì",
        },
      }
    else
      return {
        kind = {
          Text = "Ó™ì ",
          Method = "Ó™å ",
          Function = "Ó™å ",
          Constructor = "Ó™å ",
          Field = "Ó≠ü ",
          Variable = "Ó™à ",
          Class = "Ó≠õ ",
          Interface = "Ó≠° ",
          Module = "Ó™ã ",
          Property = "Ó≠• ",
          Unit = "Ó™ñ ",
          Value = "Ó™ï ",
          Enum = "Ó™ï ",
          Keyword = "Ó≠¢ ",
          Snippet = "Ó≠¶ ",
          Color = "Ó≠ú ",
          File = "Ó©ª ",
          Reference = "Ó™î ",
          Folder = "Ó™É ",
          EnumMember = "Ó≠û ",
          Constant = "Ó≠ù ",
          Struct = "Ó™ë ",
          Event = "Ó™Ü ",
          Operator = "Ó≠§ ",
          TypeParameter = "Ó™í ",
          Misc = "Ó≠£ ",
        },
        type = {
          Array = "Ó™ä ",
          Number = "Ó™ê ",
          String = "Ó™ì ",
          Boolean = "Ó™è ",
          Object = "Ó™ã ",
        },
        documents = {
          File = "Ó©ª ",
          Files = "Ó´∞ ",
          Folder = "Ó™É ",
          OpenFolder = "Ó´∑ ",
        },
        git = {
          Add = "Ó´ú ",
          Mod = "Ó´û ",
          Remove = "Ó´ü ",
          Ignore = "Ó´ù ",
          Rename = "Ó´† ",
          Diff = "Ó´° ",
          Repo = "Ó©¢ ",
          Octoface = "Ó¨ß ",
        },
        ui = {
          ArrowClosed = "Ó™∂",
          ArrowOpen = "Ó™¥",
          Lock = "Ó©µ ",
          Circle = "Ó©± ",
          BigCircle = "ÓÆ¥ ",
          BigUnfilledCircle = "ÓÆµ ",
          Close = "Ó™∏ ",
          NewFile = "Ó©ø ",
          Search = "Ó©≠ ",
          Lightbulb = "Ó©° ",
          Project = "Ó¨∞ ",
          Dashboard = "Ó´ç ",
          History = "Ó™Ç ",
          Comment = "Ó©´ ",
          Bug = "Ó™Ø ",
          Code = "Ó´Ñ ",
          Telescope = "Ó≠® ",
          Gear = "Ó´∏ ",
          Package = "Ó¨© ",
          List = "ÓÆÖ ",
          SignIn = "Ó©Ø ",
          SignOut = "Ó©Æ ",
          NoteBook = "ÓÆØ ",
          Check = "Ó™≤ ",
          Fire = "Ó´≤ ",
          Note = "Ó¨¶ ",
          BookMark = "Ó™• ",
          Pencil = "Ó©≥ ",
          ChevronRight = "Ó™∂",
          Table = "ÓÆ∑ ",
          Calendar = "Ó™∞ ",
          CloudDownload = "Ó´Ç ",
        },
        diagnostics = {
          Error = "Ó™á ",
          Warning = "Ó©¨ ",
          Information = "Ó©¥ ",
          Question = "Ó¨≤ ",
          Hint = "Ó©° ",
        },
        misc = {
          Robot = "Ó¨à ",
          Squirrel = "Ó≠ò ",
          Tag = "Ó©¶ ",
          Watch = "Ó≠º ",
          Smiley = "Ó≠î ",
          Package = "Ó¨© ",
          CircuitBoard = "Ó™æ ",
        },
      }
    end
  end

  local icn = icons()
  local kind_icons = icn.kind

  local cmp = require("cmp")
  cmp.setup({
    snippet = {
      expand = function(args)
        vim.fn["vsnip#anonymous"](args.body)
      end,
    },
    formatting = {
      fields = { "kind", "abbr", "menu" },
      format = function(entry, vim_item)
        -- Kind icons
        vim_item.kind = kind_icons[vim_item.kind]

        if entry.source.name == "copilot" then
          vim_item.kind = icn.git.Octoface
          vim_item.kind_hl_group = "CmpItemKindCopilot"
        end

        if entry.source.name == "emoji" then
          vim_item.kind = icn.misc.Smiley
          vim_item.kind_hl_group = "CmpItemKindEmoji"
        end

        if entry.source.name == "crates" then
          vim_item.kind = icn.misc.Package
          vim_item.kind_hl_group = "CmpItemKindCrate"
        end

        if entry.source.name == "lab.quick_data" then
          vim_item.kind = icn.misc.CircuitBoard
          vim_item.kind_hl_group = "CmpItemKindConstant"
        end

        -- NOTE: order matters
        vim_item.menu = ({
          nvim_lsp = "",
          nvim_lua = "",
          luasnip = "",
          buffer = "",
          path = "",
          emoji = "",
        })[entry.source.name]
        return vim_item
      end,
    },
    window = {
      completion = cmp.config.window.bordered({
        border = 'double'
      }),
      documentation = cmp.config.window.bordered({
        border = 'double'
      }),
    },
    sources = {
      { name = "nvim_lsp",                priority = 10 },
      { name = 'vsnip',                   priority = 9 },
      { name = "path",                    priority = 8 },
      { name = "buffer",                  priority = 7 },
      { name = "nvim_lsp_signature_help", priority = 6 },
      { name = "emoji",                   priority = 1 },
    },
    mapping = cmp.mapping.preset.insert({
      ["<C-p>"] = cmp.mapping.select_prev_item(),
      ["<C-n>"] = cmp.mapping.select_next_item(),
      ['<C-l>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.abort(),
      ['<C-f>'] = cmp.mapping.scroll_docs(4),
      ['<C-b>'] = cmp.mapping.scroll_docs(-4),
      ["<CR>"] = cmp.mapping.confirm { select = true },
      ["<Tab>"] = cmp.mapping(function(fallback)
        if cmp.visible() then
          cmp.select_next_item()
        elseif vim.fn["vsnip#available"](1) == 1 then
          feedkey("<Plug>(vsnip-expand-or-jump)", "")
        elseif has_words_before() then
          cmp.complete()
        else
          fallback() -- The fallback function sends a already mapped key. In this case, it's probably `<Tab>`.
        end
      end, { "i", "s" }),
      ["<S-Tab>"] = cmp.mapping(function()
        if cmp.visible() then
          cmp.select_prev_item()
        elseif vim.fn["vsnip#jumpable"](-1) == 1 then
          feedkey("<Plug>(vsnip-jump-prev)", "")
        end
      end, { "i", "s" }),
    }),
    experimental = {
      ghost_text = true,
    },
  })

  -- Set configuration for specific filetype.
  cmp.setup.filetype('gitcommit', {
    sources = cmp.config.sources({
      { name = 'cmp_git' }, -- You can specify the `cmp_git` source if you were installed it.
    }, {
      { name = 'buffer' },
    })
  })

  -- Use buffer source for `/` and `?` (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline({ '/', '?' }, {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
      { name = 'buffer' }
    }
  })

  -- Use cmdline & path source for ':' (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline(':', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      { name = 'cmdline' }
    })
  })
'''

[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-buffer'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-path'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-cmdline'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp-signature-help'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp-document-symbol'
on_event = 'VimEnter'

[[plugins]]
repo = 'onsails/lspkind.nvim'
on_event = 'VimEnter'

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_event = 'VimEnter'
lua_source = '''
  vim.g.vsnip_snippet_dir = "$HOME/.config/nvim/snippets"
'''
lua_post_source = '''
  vim.cmd [[
    autocmd User PumCompleteDone call vsnip_integ#on_complete_done(g:pum#completed_item)
    autocmd BufWritePre <buffer> lua vim.lsp.buf.format({}, 10000)
  ]]
'''

[[plugins]]
repo = 'hrsh7th/cmp-vsnip'
on_event = 'VimEnter'

[[plugins]]
repo = 'github/copilot.vim'
on_event = 'VimEnter'
lua_source = '''
  vim.g.copilot_filetypes = {
    gitcommit = true,
    markdown = true,
    yaml = true,
    text = true,
  }
  vim.g.copilot_no_tab_map = true

  vim.keymap.set(
    "i",
    "<C-c>",
    'copilot#Accept()',
    { silent = true, expr = true, script = true, replace_keycodes = false }
  )
  vim.keymap.set(
    "i",
    "<C-x>",
    '<Plug>(copilot-dismiss)'
  )
'''
lua_post_source = '''
  local function append_diff()
    -- Get the Git repository root directory
    local git_dir = vim.fn.FugitiveGitDir()
    local git_root = vim.fn.fnamemodify(git_dir, ':h')
    -- Get the diff of the staged changes relative to the Git repository root
    local diff = vim.fn.system('git -C ' .. git_root .. ' diff --cached')
    -- Add a comment character to each line of the diff
    local comment_diff = table.concat(vim.tbl_map(function(line)
      return '# ' .. line
    end, vim.split(diff, '\n')), "\n")
    -- Append the diff to the commit message
    vim.api.nvim_buf_set_lines(0, -1, -1, false, vim.split(comment_diff, '\n'))
  end
  vim.cmd [[
    autocmd BufReadPost COMMIT_EDITMSG call lua append_diff()
  ]]
'''

[[plugins]]
repo = 'williamboman/mason-lspconfig.nvim'
on_event = 'VimEnter'

[[plugins]]
repo = 'williamboman/mason.nvim'
on_event = 'VimEnter'
lua_post_source = '''
  require("mason").setup({
    ui = {
      icons = {
        package_installed = "‚úì",
        package_pending = "‚ûú",
        package_uninstalled = "‚úó"
      }
    }
  })
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_event = 'VimEnter'
depends = ['mason-lspconfig.nvim', 'cmp-nvim-lsp']
lua_post_source = '''
  local on_attach = function(client, bufnr)
    local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end

    local opts = { noremap = true, silent = true }
    buf_set_keymap("n", "K", "<cmd>lua vim.lsp.buf.hover()<CR>", opts)
    buf_set_keymap("n", "gD", "<cmd>lua vim.lsp.buf.declaration()<CR>", opts)
    buf_set_keymap("n", "gd", "<cmd>lua vim.lsp.buf.definition()<CR>", opts)
    buf_set_keymap("n", "gvd", "<cmd>:vsp<CR><cmd>lua vim.lsp.buf.definition()<CR>", opts)
    buf_set_keymap("n", "gsd", "<cmd>:sp<CR><cmd>lua vim.lsp.buf.definition()<CR>", opts)
    buf_set_keymap("n", "gi", "<cmd>lua vim.lsp.buf.implementation()<CR>", opts)
    buf_set_keymap("n", "gr", "<cmd>lua vim.lsp.buf.references()<CR>", opts)
    buf_set_keymap('n', 'gt', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
    buf_set_keymap("n", "gn", "<cmd>lua vim.lsp.buf.rename()<CR>", opts)
    buf_set_keymap("n", "gf", "<cmd>lua vim.lsp.buf.format { async = true }<CR>", opts)
    buf_set_keymap('n', 'ge', '<cmd>lua vim.diagnostic.open_float()<CR>', opts)
    buf_set_keymap("n", "<C-k>", "<cmd>lua vim.lsp.buf.signature_help()<CR>", opts)
    buf_set_keymap("n", "<space>wa", "<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>", opts)
    buf_set_keymap("n", "<space>wr", "<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>", opts)
    buf_set_keymap("n", "<space>wl", "<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>", opts)
    buf_set_keymap("n", "<space>D", "<cmd>lua vim.lsp.buf.type_definition()<CR>", opts)
    buf_set_keymap("n", "<space>ca", "<cmd>lua vim.lsp.buf.code_action()<CR>", opts)
    buf_set_keymap("n", "<space>e", "<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>", opts)
    buf_set_keymap("n", "[d", "<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>", opts)
    buf_set_keymap("n", "]d", "<cmd>lua vim.lsp.diagnostic.goto_next()<CR>", opts)
    buf_set_keymap("n", "<space>q", "<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>", opts)
  end

  local capabilities = require('cmp_nvim_lsp').default_capabilities()
  capabilities.textDocument.completion.completionItem.snippetSupport = true

  vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
    vim.lsp.diagnostic.on_publish_diagnostics, {
      underline = true,
      virtual_text = true,
      signs = true,
      update_in_insert = false,
    }
  )
  -- diagnostic sign setting
  local signs = { Error = "üôÖ", Warn = "‚ö†Ô∏è", Hint = "üí°", Info = "üôã" }
  for type, icon in pairs(signs) do
    local hl = "DiagnosticSign" .. type
    vim.fn.sign_define(hl, { text = icon, texthl = hl, numhl = hl })
  end

  local nvim_lsp = require("lspconfig")
  -- require("mason-lspconfig").setup()
  require("mason-lspconfig").setup_handlers {
    function(server_name)
      local opt = {
        on_attach = on_attach,
        capabilities = capabilities,
      }
      if server_name == "gopls" then
        opt.settings = {
          gopls = {
            env = { GOFLAGS = "-tags=integration,!integration,wireinject" },
            gofumpt = true,
          },
        }
      elseif server_name == "tsserver" then
        -- package.json „Å® deno.json „Åå„ÅÇ„Çã„Éá„Ç£„É¨„ÇØ„Éà„É™Â†¥Âêà„ÅØ tsserver „Çí‰Ωø„ÅÜ
        opt.root_dir = nvim_lsp.util.root_pattern("package.json")
      elseif server_name == "denols" then
        opt.root_dir = nvim_lsp.util.root_pattern("deno.json")
      end
      nvim_lsp[server_name].setup(opt)
    end
  }
'''

[[plugins]]
repo = 'stevearc/aerial.nvim'
on_event = 'VimEnter'
lua_post_source = '''
  require("aerial").setup({
    layout = {
      -- These control the width of the aerial window.
      -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
      -- min_width and max_width can be a list of mixed types.
      -- max_width = {40, 0.2} means "the lesser of 40 columns or 20% of total"
      max_width = { 50, 0.2 },
      width = nil,
      min_width = 30,

      -- key-value pairs of window-local options for aerial window (e.g. winhl)
      win_opts = {},

      -- Determines the default direction to open the aerial window. The 'prefer'
      -- options will open the window in the other direction *if* there is a
      -- different buffer in the way of the preferred direction
      -- Enum: prefer_right, prefer_left, right, left, float
      default_direction = "prefer_right",

      -- Determines where the aerial window will be opened
      --   edge   - open aerial at the far right/left of the editor
      --   window - open aerial to the right/left of the current window
      placement = "window",

      -- When the symbols change, resize the aerial window (within min/max constraints) to fit
      resize_to_content = true,

      -- Preserve window size equality with (:help CTRL-W_=)
      preserve_equality = false,
    }
  })
'''
